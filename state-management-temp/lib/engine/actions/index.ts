import invariant from "tiny-invariant";
import { getPercent, getPrices, InvestmentKind } from "../history";

/**
 * A classification of actions, used for segregating actions in the UI. Non-exhaustive.
 */
export type ActionKind = "investment" | "income" | "expense" | "other";

/**
 * A classification of the time unit in which the simulation is performed.
 * Not used in the simulation, but is used to determine the unit of measurement for the metrics in the UI.
 * Values for specific quest descriptions should be chosen such, to make sense for the tick kind.
 */
export type TickKind = "week" | "month" | "year";

/**
 * A discrete moment (year, month, week, etc.) in time, during which the state of the world is recorded.
 * The step includes the values of all metrics at the moment in time.
 */
export type Step = {
	/**
	 * A tick is a blanket term for either the year/month/week in which the step occurs.
	 * Tick can be thought of as the "time" of the step and contains numeric values like `2025`, `1` (1st week), etc.
	 * Tick values are **unique** for the entire simulation of steps. Each subsequent step always has a tick value **one greater than the previous one**.
	 * Only the first step's tick can be determined by the description, the rest are predictably generated by the engine by incrementing the tick of the previous step.
	 * @see {@link TickKind}
	 */
	tick: number;
	/**
	 * A metric, representing the amount of money in the bank account the user currently has.
	 * This is in no specific currency. It's the money that user can immediately spend and does *NOT* include any other assets (e.g. stocks, real estate, etc.).
	 * Other assets, such as investments, are stored in the corresponding {@link Action}.
	 * Whenever an investment (etc.) action is finished, the corresponding money is added to the bank account metric value and the action is removed from the list of active actions.
	 */
	bankAccount: number;
	/**
	 * A metric, representing the amount of joy the user currently has.
	 * This is a number between 0 and 100.
	 */
	joy: number;
	/**
	 * A metric, representing the amount of free time the user currently has in hours/tick.
	 * Frontend may use the {@link TickKind} from the {@link QuestDescription} to determine the unit of measurement (e.g. hours per week, hours per month, etc.).
	 */
	freeTimeHours: number;
	/**
	 * A list of actions that were started before the start of the current step, but after the end of the previous step.
	 * The result of these actions is already apparent in the current step.
	 *
	 * Note: They are applied after all pre-existing actions.
	 *
	 * If any of these actions are still relevant after the current step, they will be added to the list of {@link oldActiveActions} with a decremented {@link remainingTicks}.
	 */
	newActions: Action[];
	/**
	 * A list of actions that were started in any previous step, but are still relevant in the current step (and potentially in future steps).
	 * The result of these actions is already apparent in the current step.
	 */
	oldActiveActions: Action[];
};

/**
 * An encapsulation of a numeric percentage value.
 * It can either be a constant value, or a varying value that is looked up from an investment's price history each time when it needs to be evaluated.
 */
export type RepeatedPercent =
	| {
			source: "constant";
			percent: number;
	  }
	| {
			source: "history";
			investmentKind: InvestmentKind;
	  };

/**
 * Creates a {@link RepeatedPercent} that is a constant value.
 * @param percent - The percentage value (-100% to 100%).
 * @returns A {@link RepeatedPercent} that is a constant value.
 */
export const constantPercent = (percent: number): RepeatedPercent => ({
	source: "constant",
	percent,
});

/**
 * Creates a {@link RepeatedPercent} that is a varying value, looked up from an investment's price history each time when it needs to be evaluated.
 * @param investmentKind - The kind of investment that the percentage value is looked up from.
 * @returns A {@link RepeatedPercent} that is a varying value.
 */
export const historyPercent = (
	investmentKind: InvestmentKind
): RepeatedPercent => ({
	source: "history",
	investmentKind,
});

/**
 * A general description of how a metric is affected by an action.
 * Each of its values can be configured to achieve simple and complex modifications of the metric's numeric value.
 *
 * Application happens as follows:
 * newValue = (100 + repeatedPercent) / 100 * (previousValue + repeatedAbsoluteDelta)
 */
export type MetricImpact = {
	/**
	 * Whether or not this impact should be applied.
	 * If `false`, none of the other values are considered and the metric is not affected.
	 */
	hasImpact: boolean;
	/**
	 * The minimum required value of the metric for the impact to be applied.
	 * If the metric is less than this value, the impact is not applied.
	 * @default -Infinity
	 */
	minRequired: number;
	/**
	 * The maximum required value of the metric for the impact to be applied.
	 * If the metric is greater than this value, the impact is not applied.
	 * @default Infinity
	 */
	maxRequired: number;
	/**
	 * A constant value that is added to the metric every time.
	 * @default 0
	 */
	repeatedAbsoluteDelta: number;
	/**
	 * A percentage value that is added to the metric every time.
	 * @default 0
	 */
	repeatedPercent: RepeatedPercent;

	initialPrice: number;
	repeatedPrice: number;
};

/**
 * A {@link MetricImpact} value that does not have any effect on the metric.
 * It is used as a default value for {@link MetricImpact}.
 */
export const noImpact: MetricImpact = {
	hasImpact: false,
	minRequired: -Infinity,
	maxRequired: Infinity,

	repeatedAbsoluteDelta: 0,
	repeatedPercent: { source: "constant", percent: 0 },

	initialPrice: 0,
	repeatedPrice: 0,
};

/**
 * Creates a {@link MetricImpact} value from a partial {@link MetricImpact} value.
 * @param partialImpact - The partial {@link MetricImpact} value to create from. Any missing values are set to their defaults, set in {@link noImpact}.
 * @returns A {@link MetricImpact} value.
 */
export const impact = (partialImpact: Partial<MetricImpact>) => ({
	...noImpact,
	hasImpact: true,
	...partialImpact,
});

/**
 * Creates a {@link MetricImpact} value that has a constant percentage impact.
 * @param percent - The percentage value (-100% to 100%).
 * @returns A {@link MetricImpact} value.
 */
export const percentImpact = (percent: number) =>
	impact({ repeatedPercent: { source: "constant", percent } });

/**
 * Creates a {@link MetricImpact} value that has a constant absolute impact.
 * @param absoluteDelta - The absolute value to add to the metric.
 * @returns A {@link MetricImpact} value.
 */
export const absoluteImpact = (absoluteDelta: number) =>
	impact({ repeatedAbsoluteDelta: absoluteDelta });

/**
 * A description of an action that can be started by the user.
 *
 * It is an instance of an action â€“ eg. if user invests twice, 2 distinct actions are created.
 */
export type Action = {
	/**
	 * The name of the action.
	 */
	name: string;
	/**
	 * @see {@link ActionKind}
	 */
	kind: ActionKind;
	/**
	 * A short description of the action for UI display.
	 */
	shortDescription: string;
	/**
	 * A detailed description of the action for LLM context.
	 */
	llmDescription: string;
	/**
	 * The number of ticks that the action will be applied.
	 *
	 * If this action is currently being added, the value will be the duration in ticks that it will be relevant.
	 * After it was applied, the number is decremented by 1 and represents how many more ticks it will be relevant for.
	 *
	 * When the value reaches 0, the action is finished and the {@link capital} of the action (if any) is added to the bank account.
	 */
	remainingTicks: number;

	/**
	 * A description of how the bank account metric is affected by the action.
	 */
	bankAccountImpact: MetricImpact;
	/**
	 * A description of how the investment metric is affected by the action.
	 */
	investmentImpact: MetricImpact;
	/**
	 * A description of how the joy metric is affected by the action.
	 */
	joyImpact: MetricImpact;
	/**
	 * A description of how the free time metric is affected by the action.
	 */
	freeTimeImpact: MetricImpact;

	/**
	 * The amount of money that the action will add to the bank account. Relevant only for actions that add money to the bank account (e.g. investments).
	 */
	capital: number;

	canChangeInitialPrice?: boolean;
	canChangeRepeatedPrice?: boolean;
};

function calculateMetric(
	metricImpact: MetricImpact,
	previousValue: number,
	tick: number,
	tickKind: TickKind
) {
	if (!metricImpact.hasImpact) {
		return previousValue;
	}

	const percent =
		metricImpact.repeatedPercent.source == "constant"
			? metricImpact.repeatedPercent.percent
			: getPercent(
					tick,
					tickKind,
					getPrices(metricImpact.repeatedPercent.investmentKind)
			  );

	const absoluteValue = previousValue + metricImpact.repeatedAbsoluteDelta;
	return absoluteValue + absoluteValue * (percent / 100);
}

function applyAction(
	action: Action,
	step: Step,
	isNew: boolean,
	tickKind: TickKind
) {
	const newAction = { ...action };
	newAction.capital = calculateMetric(
		action.investmentImpact,
		action.investmentImpact.repeatedPrice +
			(isNew ? action.investmentImpact.initialPrice : action.capital),
		step.tick,
		tickKind
	);
	newAction.remainingTicks--;

	return {
		...step,
		bankAccount:
			calculateMetric(
				action.bankAccountImpact,
				step.bankAccount,
				step.tick,
				tickKind
			) -
			(isNew ? newAction.investmentImpact.initialPrice : 0) -
			newAction.investmentImpact.repeatedPrice,
		joy: calculateMetric(action.joyImpact, step.joy, step.tick, tickKind),
		freeTimeHours: calculateMetric(
			action.freeTimeImpact,
			step.freeTimeHours,
			step.tick,
			tickKind
		),

		oldActiveActions: [...step.oldActiveActions, newAction],
	} satisfies Step;
}

function isActionFinished(action: Action) {
	invariant(
		action.remainingTicks >= 0,
		"Remaining ticks must be non-negative"
	);
	return action.remainingTicks === 0;
}

function finishAction(action: Action, step: Step) {
	invariant(
		isActionFinished(action),
		"Non-finished actions cannot be finalized"
	);

	return {
		...step,
		bankAccount: step.bankAccount + action.capital,
	} satisfies Step;
}

/**
 * Computes the next step in the simulation, given the previous step and the new actions to added.
 * @param previousStep - The previous step in the simulation.
 * @param newActions - The new actions to be applied in the next step.
 * @param tickKind - The kind of tick to use for the next step.
 * @returns The next step in the simulation.
 */
export function computeNextStep(
	previousStep: Step,
	newActions: Action[],
	tickKind: TickKind
) {
	let nextStep: Step = {
		...previousStep,
		newActions,
		oldActiveActions: [],
		freeTimeHours: 0,
		tick: previousStep.tick + 1,
	};

	for (const action of previousStep.oldActiveActions) {
		if (isActionFinished(action)) {
			nextStep = finishAction(action, nextStep);
		} else {
			nextStep = applyAction(
				action,
				nextStep,
				/* isNew: */ false,
				tickKind
			);
		}
	}

	for (const action of newActions) {
		nextStep = applyAction(action, nextStep, /* isNew: */ true, tickKind);
	}

	return nextStep;
}
